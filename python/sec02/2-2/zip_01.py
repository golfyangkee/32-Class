
def Test():
        #목록을 한꺼 번에 묶어서 리턴 1,10: 2,20: 3,30으로 리턴된다.
        # zip ( ,,,,,)  ->for로 풀어낸다.
        #목록에서 가장 짧은 객체를 기준으로 페어를 만든다.
        # 색인과 랭스만 기억하고 형태는 상관없다.
        for x, y ,z in zip ([print('abc'), 2, (3,4),[5,6,7]], [10, 20, 30, 40, None],[11, 20, 33, print('efg'), 50] ) :
                # 정렬이 아닌 그저 시퀀스이다.
                print (f'{x}  :   {y}  : {z}' )
                # 리턴이 없는 애들을 불러다가 리턴이 있는 자리에 넣으면 None로 받아들인다.

def Test01():
        #목록을 묶어서 set으로 리턴
        print("====> ", set(zip ( ['a', 'b', 'c','d','d'], [1, 2, 3,'d','d'])))
        # {('d', 'd'), ('b', 2), ('a', 1), ('c', 3)} 순서 상관없이 정렬이 아니고 중복값 제거
        res = set(zip ( ['a', 'b', 'c','d','d'], [1, 2, 3,'d','d']))

        print(type(res)) # 보이는 거는 dict 인데 set 타입이다. : 없으면 {}이여야도 set이다.
        print(res)

        print("====> ", zip(['a', 'b', 'c', 'd', 'd'], [1, 2, 3, 'd', 'd']))
        # zip()도 range() 같이 가지고 만 있고 나열하는 애들은 아니다. 나열을 위해서는 set이나 for해야한다.

def Test02():
        #목록을 묶어서 dict로 리턴
        keys = ['cat', 'dog', 'duck']
        values = ['야옹', '멍멍', '꽥꽥']
        print (dict(zip(keys, values)))
        # 딕트로 진행해보자

if __name__ == '__main__':
    Test01()

'''
set은 값을 값으로 관리하기 때문에 정렬이 아니다.
help(zip) 하면
인덱스를 가지고 있는 이터레이블을 줄 수 있고
문자열, 레인지 등등 올 수 있다.
가장 짧은 애 기준
괄호 안에 첫번째 매개인자가 *이니까 계수에 상관없이 인덱스를 가지고 반복할 수 있다.?? 먼 솔 ㅋㅋㅋ
'''
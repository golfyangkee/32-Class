'''
a,b라는 변수를 Test라는 이름의 자료형을 등록하고 싶다.
선언 -> 객체생성 -> 멤버호출 (값 전달 및 변경 리턴)
    a       b       --------------- Test
    100     200     t1 레코드 방
    300     400     t2 레코드 방
    500     600     t2 레코드 방
'''
# [1] 선언
class Test:
    # 변수를 선언하고 초기화 하는 메소드 (생성자) -> 객체를 생성할 때 단 한번만 호출된다. / 명시호출하지 않는다.    # int(a,b) == a,b 이렇게 선언해도 된다.
    def __init__(self, a, b):   # 나만의 자료형 만들기 (self 는 예약되어 있는 예약어가 아니다 키워드 리스트에 없는 애라 변수처럼 씀)
                                # 첫번째 자리에는 히든으로 self라고 명시하는 것 /
                                # this: 현재 오브젝트를 지칭하는 연산자 인데 this말고 self라고 쓴다.
                                # self: 현재 오브젝트를 지징하는 변수(연산자x, 키워드x) / 명칭은 상관없다.
                                # __init__: 생성자, 7개 규칙들이 있는데 파이썬은 유연해서
        self.a=a    #테스트멤버변수 = 지역변수
        self.b=b

if __name__ == '__main__':
# [2] 객체 생성
    t1=Test(100,200)    # t1.a = 100, t1.b =200
# [3] 멤버 호출
    print(f"{t1.a} {t1.b}")     #100 200
    t2 = Test(300,400)
    print(f"{t2.a} {t2.b}")     #300 400
    print(t1.a) #100
    t3=Test(500,600)
    print(f"{t3.a} {t3.b}")     #500 600

    # t1.a를 3000으로 변경 후 출력
    t1.a=3000
    print(f"{t1.a} {t1.b}")     #3000 200

    # 각 stack 객체의  t1, t2, t3 주소를 출력해 보자.
    print("t1의 주소 :", id(t1))   #1604559076048
    print("t2의 주소 :", id(t2))   #1604559076288
    print("t3의 주소 :", id(t3))   #1604559076336
    print("Test의 주소 :", id(Test))
    print("=========================")
    # 각 heap 객체의 &Test(100,200), &Test(300,400), &Test(500,600) 할당된 참조 주소를 출력해 보자
    print(t1)   #<__main__.Test object at 0x00000175972C7AD0> Test클래스는 __repr__없네
    print(t2)   #<__main__.Test object at 0x00000175972C7BC0>
    print(t3)   #<__main__.Test object at 0x00000175972C7BF0>
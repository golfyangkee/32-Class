프로그램 사용 시 메모리사용과 관련된 성능 및 최적화 문제를 다룰 때 유용하다.

1) MemoryMap : cs, ds, static, heap, stack -> PVM: Python Virtual Machine 관리영역이 아니라 실행영역
                정보처리 기사 단골 문제 3~4문제 / 각각의 주소를 번지로 관리하듯이 여기는 관리영역이 아니라 실행 영역에 대한 구역이다.
    cs(code segment) 코드영역 : 프로그램 소스코드가 저장되는 영역, 실행 가능한 명령어 집합
    ds(data segment) 데이터 영역, 변수(전역, 정적)가 저장 및 관리되는 영역, 프로그램 실행이 끝날 때까지 유지
    static 정적영역 : &class, &function, &struct, &union, &static로 선언된 자료형 _ 선언과 동시에 주소가 생성된다
    선언을 하게 되면 주소를 가지고 대기를 하고 있어 바운딩(오피스 책에서 바운드나 바운딩을 얘기한다)한다고 한다.
    heap 동적할당 영역 : 동적으로 메모리가 저장되는 영역,
                    프로그램이 실행 시 다른 프로세스가 실행되지 않는 공간을 할당했다가 (동적할당)
                    실행이 끝나면 소거되는 영역 (소멸, GC: 가베지 컬랙터) // 할당키워드랑 소멸키워드
    stack 고정영역 : 함수 호출과 관련된 임시데이터가 저장되는 곳, 함수의 매개변수, 지역변수 등이 저장되는 영역
                    고정 영역이 꽉 차면 os가 움직이지 않아서 hist 쿠키 휴지통 순으로 삭제 프로그램이 계속 체크하는 곳
                    줌 하다보면 열려있는 리소스가 많아서 시스템이 반응이 기타 등등할 수 있다고 하면 가상 메모리 열어서 사용하면 된다.
                    메모리가 부족하다기 보다는 가상영역에서 공간을 할당할때 구현되는 내용이다.

메모리 맵을 다 쓴다. 해당 프로그램이 플랫폼에 귀속적이다. : 프로그램이 가지고 있는 메모리맵을 쓰겠다. 윈도우가 메모리맵을 다 쓰겠다.
프로그램에 따라 크기가 결정된다.
객체지향 프로그램은 플랫폼에 독립적이다 라고 말한다.
영역을 안 쓰고 자체적으로 프로그램 설치를 할 때 전체적으로 heap
메모리 실행이 os에 귀속되지 않는다고 판단
실행은 가상메모리에서 실행을 하고
메모리맵은 자체적으로 자유영역 공간 안에다가 내가 안에서 분류해서 쓰겠다.
python&java(객체지향프로그램)은 일반프로그램이고

C++ 도 프로그램 설치 되면 자기만에 메모리 공간이 생성 -> heap공간 생성
프로그램이 실행되지 않을 때는 남은 heap공간을 다른 애가 와서 실행해도 됨
코드 작성 시 자료형을 가져다가 클래스를 만들어서 자기영역 공간을
os는 한 영역이 꽉차면 나머지 애들은 병목현상을 만든다.
플랫폼에 귀속되고 있는 프로그램 1위가 마이크로소프트 프로그램들
동적할당들은 다른 곳에서 실행이 되었으면 좋겠다.
class를 만들면 static 중 static로 선언된 자료형 빼고는 다 동적할당 할 수 있다.
class Test {
    int a, b

}

Test t1 = new Test()

************************PVM 크기, 메모리 용량, 코드 크기, 런타임 모듈 확인 (추가 모듈: memory_profiler, psutil)
python -v 로 봤었다.

2) PVM : cs, ds, static, heap, stack ( .py -> .pyc(바이트코드로 컴파일)
    cs(code segment) 코드영역 : 파이썬 소스 코드가 바이트 코드로 컴파일되어 로드되는 곳
    ds(data segment) 데이터 영역 : 모듈에 선언된 변수가 저장
    static 정적영역 : 파이썬은 &class &function @static 으로 선언된 자료형은 heap에서 함께 관리된다.
                    파이썬에서는 명시적으로 쓰지 않고(heap안에 있어서) 바운드 바인딩만 한다?
    heap 동적할당 영역: 메모리 할당되는 영역, 파이썬의 자료형 객체가 할당되는 곳, 기본적으로 객체 리스트 딕셔너리 등 할당됨
    stack 고정영역 : 함수호출 시 실행 컨텍스트가 저장되는 곳

프로그램에 귀속되는 애들은
영역 주소 관리를 서버가 하는데
프로그램에 독립되는 애들은
메모리맵 전체를 heap으로 쓰고 내가 알아서 나눠서 쓰겠다.

===============================================================================================================

3) PVM 언제 실행?
    - python 인터프린터 실행 : 쉘에서 python 입력하면 이때 실행
    -> 실행이 되면서 동시에 PVM 초기화(내장모듈임포트, 시스템환경설정 등)를 한다.
    -> 바이트코드 컴파일 -> 바이트 코드 실행

과제 함수를 람다로 바꿔보는 연습을 해보자.

===========================================================================================================
4) a_class.py 클래스 선언 방식 및 호출
    클래스란? 사용자 자료형이다. = user datatype
        - 자주 사용하는 변수, 메소드 등을 하나의 이름으로 등록하는 자료형
        - 속성 + 기능 (변수+메소드)
        ex) a, b 변수만 맨날 쓴다고 하면
            a, b 라는 변수를 Test라는 나만의 자료형을 만들고 싶다.
            파이썬이 제공해주는 시퀀스 연산자 자료형을 가지고
            나만의 class를 만드는 것
            class Test: # 사용자 자료형 Test를 만들었다 글보다는 그림을 잘 보면 된다.
                int a
                int b
    [ 선언법 ]
    class userName:
        변수, 메소드(생성자, 소멸자, 특수기능을 가지고 있는 추가 메소드 등등)

    나도 모르게 object(선조)가 있고 test(후손)가 있어서 상속 관계를 만들어서 다단계 인생이 되는 것
    선언을 하면 애를 어떻게 가져다 쓰는 걸까?
    변수는 내가 자주 사용하는 데 값을 다 다르게 줄때는?
    1월 2월 달마다 금액이 다른데
    실제 변수는 만들어 놓고 할건지 안 할 건지
    다 만들어 놓고 호출하는 방법이 다르다는 거는
    값이 다르다는 거다.
    변수도 공통 하는 일도 공통인데 값이 다르다.
    유저자료형을 만드는 이유가 데이터를 보고 만든다.
    ////////////////////////////////////////
    a   b
    100 200 (+)
    300 400 (-)
    500 600 (*)
레코드 단위로 객체 단위로
변수는 칼럼단위로
name    kor     eng     mat
홍길동     90      80      70
정길동     50      60      70
이길동     100     100     100

5) a_class02.py  b_class02.py -> __repr__메소드 재정의 및 self 개념

6) c_class.py 생성자

    - 생성자란 클래스 객체를 생성할 때 단 한번만 호출되는 메소드 __init__
    - 생성자를 명시하지 않으면 매개인자 없는 기본 생성자가 자동으로 호출되어 객체가 생성된다.
    (생성자를 명시하면 명시된 생성자가 호출되고 명시하지 않으면 기본 생성자가 호출되어 객체가 생성된다.)
    - 생성자는 메소드처럼 객체.멤버로 호출하지 않는다.
    - 생성자는 상속되지 않는다.

7) d_class.py
    생성자의 기본 값을 전달해서 매개인자 유무에 따라 호출할 수 있는 하나의 생성자를 만들어서 객체를 생성해 보자.

8) e_class01_list.py e_class02_list.py -> Test(), Score() 객체 생성시 시퀀스로 변환 후 출력하고 싶다.
    - Packing   : 여러 값을 하나의 변수로 묶는 것 my_tuple = 10,10,30; my_list = [1,2,3]
    - Unpacking : 패킹된 값을 다시 개별 변수로 추출하는 것
            a,b,c = my_tuple
            x,y,z = my_list
===========================================================================
클래스 재정의 메소드 ( 상속 : 선조의 객체가 먼저 생성되고 후손이 나중에 생성된다. )
    1) __init__ -> None     : 객체를 초기화 및 생성, 객체가 메모리에 올라가면서 생성된 후 호출된다. (용도: 멤버범수 초기화, 설정 및 초기화)
                                ex) def __init__(self):
                                        self.name="noname"
    2) __new__  -> Object   : 객체 생성을 담당, 객체가 생선되기 전 호출된다. (용도 : 멤버들이 올라오기 전에 객체간의 연산을 할때, 객체생성을 제어 및 수정)
                                ex) def __new__(cls):
                                        res = super(MyClass, cls).__new__(cls)
                                        return res
                                ex) t1=Test(100), t2=Test(200) if t1.a == t2.a 이거 말고 if t1==t2: -> 객체가 가진 주소가 아닌 값으로 구현하고 싶을 때
                                    객체간 연산을 할 때 사용되는 함수도 있고 __new__로 객체제어도 한다.
     tip:__new__메소드로 객체 생성과정을 커스터마이즈하고 사용자 정의 속성을 추가하면 __init__메소드는 초기화작업을 한다. (두개 같이 썼을 때)
    3) __repr__ -> str      : 사용자가 이해하기 쉬운(서식을 맞춘다; 정규화출력) 문자열로 리턴 {} / repr(obj)  -> 디버깅(객체식별정보)
    4) __str__  -> str      : 친화적인 문자열을 리턴, str(obj)=str(f'') 또는 print() 후 문자열 리턴, 단문때는 안씀 -> 문자열로 리턴
                            